/*
 * DICOM software development library (SDL)
 * Copyright (c) 2010-2020, Kim, Tae-Sung. All rights reserved.
 * See copyright.txt for details.
 *
 * dicom.h
 */

#ifndef DICOMSDL_DICOM_H_
#define DICOMSDL_DICOM_H_

#include <string.h>

#include <functional>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "dicomcfg.h"

namespace dicom {

class DataSet;
class DataElement;
class InStream;
class Sequence;
class PixelSequence;
class DicomException;

// Types -======================================================================

// VR ------------------------------------------------------------------------

struct VR {
  typedef enum: int16_t {
    NONE = 0,

// VR const names are generated by 'codegenerator_valueprepresentations.py'.
// Place $$Generated_VR code in 'src/include/dicom.h'.
    AE, AS, AT, CS, DA, DS, DT, FL, FD, IS, LO, LT, OB, OD, OF, OL,
    OV, OW, PN, SH, SL, SQ, SS, ST, SV, TM, UC, UI, UL, UN, UR, US,
    UT, UV,
// $$End_VR of generated code.

    /** `VR_PIXSEQ` is a custom VR only used in the DICOMSDL; A `DataElement`
     * with `VR_PIXSEQ` contains encoded pixel data. */
PIXSEQ,

    /** `VR_OFFSET` is a custom VR in this DICOM implementation.
     * A `DataElement` with `VR_OFFSET` contains offset of a directory record.
     * Any data elements with `(0004,1200)`, `(0004,1202)`, `(0004,1400)`
     * or `(0004,1420)` will have this VR. */
    OFFSET, UNKNOWN = -1
  } type;
  // 'OV', 'SV', 'UV' are new VRs since 2017 version.

  static const char* repr(type vr);
  static type from_uint16le(uint16_t u);
  static type from_string(const char *s);
};
typedef VR::type vr_t;

// TAG -----------------------------------------------------------------------

typedef uint32_t tag_t;

struct TAG {
  inline static tag_t build(uint16_t gggg, uint16_t eeee) {
    return (tag_t(gggg) << 16) + eeee;
  }

  inline static tag_t load_32le(void* p) {
    return build(load_le<uint16_t>(p), load_le<uint16_t>((uint8_t*)(p) + 2));
  }

  inline static tag_t load_32e(void* p, bool is_little_endian) {
    if (is_little_endian)
      return build(load_le<uint16_t>(p), load_le<uint16_t>((uint8_t*)(p) + 2));
    else
      return build(load_be<uint16_t>(p), load_be<uint16_t>((uint8_t*)(p) + 2));
  }

  inline static uint16_t group(tag_t tag) { return (uint16_t)(tag >> 16); }
  inline static uint16_t element(tag_t tag) { return (uint16_t)(tag & 0xffff); }

  /// Tag -> std::string "(gggg,eeee)""
  static std::string repr(tag_t tag);

  static vr_t get_vr(tag_t tag); // Tag::vr(tag);
  static const char* keyword(tag_t tag); // Tag::keyword(tag)
  static const char* name(tag_t tag); // Tag::name(tag)
  static tag_t from_keyword(const char* keyword); // Tag::from_keyword(string)
};

// UID -----------------------------------------------------------------------

struct UID {
  typedef enum {
// UID const names are generated by 'codegenerator_builddictionary.py'
// $$Generated_UID code is placed here.
    VERIFICATION_SOP_CLASS = 0,
    IMPLICIT_VR_LITTLE_ENDIAN = 1,
    EXPLICIT_VR_LITTLE_ENDIAN = 2,
    DEFLATED_EXPLICIT_VR_LITTLE_ENDIAN = 3,
    EXPLICIT_VR_BIG_ENDIAN = 4,
    JPEG_BASELINE_PROCESS1 = 5,
    JPEG_EXTENDED_PROCESS2AND4 = 6,
    JPEG_EXTENDED_PROCESS3AND5 = 7,
    JPEG_SPECTRAL_SELECTION_NONHIERARCHICAL_PROCESS6AND8 = 8,
    JPEG_SPECTRAL_SELECTION_NONHIERARCHICAL_PROCESS7AND9 = 9,
    JPEG_FULL_PROGRESSION_NONHIERARCHICAL_PROCESS10AND12 = 10,
    JPEG_FULL_PROGRESSION_NONHIERARCHICAL_PROCESS11AND13 = 11,
    JPEG_LOSSLESS_NONHIERARCHICAL_PROCESS14 = 12,
    JPEG_LOSSLESS_NONHIERARCHICAL_PROCESS15 = 13,
    JPEG_EXTENDED_HIERARCHICAL_PROCESS16AND18 = 14,
    JPEG_EXTENDED_HIERARCHICAL_PROCESS17AND19 = 15,
    JPEG_SPECTRAL_SELECTION_HIERARCHICAL_PROCESS20AND22 = 16,
    JPEG_SPECTRAL_SELECTION_HIERARCHICAL_PROCESS21AND23 = 17,
    JPEG_FULL_PROGRESSION_HIERARCHICAL_PROCESS24AND26 = 18,
    JPEG_FULL_PROGRESSION_HIERARCHICAL_PROCESS25AND27 = 19,
    JPEG_LOSSLESS_HIERARCHICAL_PROCESS28 = 20,
    JPEG_LOSSLESS_HIERARCHICAL_PROCESS29 = 21,
    JPEG_LOSSLESS_NONHIERARCHICAL_FIRSTORDER_PREDICTION_PROCESS14 = 22,
    JPEGLS_LOSSLESS_IMAGE_COMPRESSION = 23,
    JPEGLS_LOSSY_NEARLOSSLESS_IMAGE_COMPRESSION = 24,
    JPEG2000_IMAGE_COMPRESSION_LOSSLESS_ONLY = 25,
    JPEG2000_IMAGE_COMPRESSION = 26,
    JPEG2000_PART2_MULTICOMPONENT_IMAGE_COMPRESSION_LOSSLESS_ONLY = 27,
    JPEG2000_PART2_MULTICOMPONENT_IMAGE_COMPRESSION = 28,
    JPIP_REFERENCED = 29,
    JPIP_REFERENCED_DEFLATE = 30,
    MPEG2_MAIN_PROFILE_MAIN_LEVEL = 31,
    MPEG2_MAIN_PROFILE_HIGH_LEVEL = 32,
    MPEG4_AVC_H264_HIGH_PROFILE_LEVEL41 = 33,
    MPEG4_AVC_H264_BDCOMPATIBLE_HIGH_PROFILE_LEVEL41 = 34,
    MPEG4_AVC_H264_HIGH_PROFILE_LEVEL42_FOR_2D_VIDEO = 35,
    MPEG4_AVC_H264_HIGH_PROFILE_LEVEL42_FOR_3D_VIDEO = 36,
    MPEG4_AVC_H264_STEREO_HIGH_PROFILE_LEVEL42 = 37,
    HEVC_H265_MAIN_PROFILE_LEVEL_51 = 38,
    HEVC_H265_MAIN_10_PROFILE_LEVEL_51 = 39,
    RLE_LOSSLESS = 40,
    RFC_2557_MIME_ENCAPSULATION = 41,
    XML_ENCODING = 42,
    SMPTE_ST_211020_UNCOMPRESSED_PROGRESSIVE_ACTIVE_VIDEO = 43,
    SMPTE_ST_211020_UNCOMPRESSED_INTERLACED_ACTIVE_VIDEO = 44,
    SMPTE_ST_211030_PCM_DIGITAL_AUDIO = 45,
    PAPYRUS_3_IMPLICIT_VR_LITTLE_ENDIAN = 78,
// $$End_UID of generated code.
    UNKNOWN = -1
  } type;

  /*
    uidvalue: "1.2.840.10008.1.2.1"
    uidname: "Explicit VR Little Endian"
    uid: EXPLICIT_VR_LITTLE_ENDIAN
  */
  static type from_uidvalue(
      const char* uidvalue);                // UID::from_uidvalue("1.2.")
  static const char* to_uidname(type uid);  // UID::to_uidname(UID::JPEG...)
  static const char* to_uidvalue(type uid); // UID::to_uidvalue(UID::JPEG...)
  static const char* uidvalue_to_uidname(const char* uidvalue);
};
typedef UID::type tsuid_t;

// CHARSET--------------------------------------------------------------------

struct CHARSET {
  typedef enum {
    DEFAULT = 0,
    ISO_IR_6,    // default repertoire
    ISO_IR_100,  // latin_1
    ISO_IR_101,  // latin_2
    ISO_IR_109,  // latin_3
    ISO_IR_110,  // latin_4
    ISO_IR_144,  // cyrillic
    ISO_IR_127,  // arabic
    ISO_IR_126,  // greek
    ISO_IR_138,  // hebrew
    ISO_IR_148,  // latin_5
    ISO_IR_13,  // japanese jis x 0201
    ISO_IR_166,  // thai
    ISO_2022_IR_6,  // default
    ISO_2022_IR_100,  // latin_1
    ISO_2022_IR_101,  // latin_2
    ISO_2022_IR_109,  // latin_3
    ISO_2022_IR_110,  // latin_4
    ISO_2022_IR_144,  // cyrillic
    ISO_2022_IR_127,  // arabic
    ISO_2022_IR_126,  // greek
    ISO_2022_IR_138,  // hebrew
    ISO_2022_IR_148,  // latin_5
    ISO_2022_IR_13,  // japanese jis x 0201
    ISO_2022_IR_166,  // thai
    ISO_2022_IR_87,  // japanese jis x 0208
    ISO_2022_IR_159,  // japanese jis x 0212
    ISO_2022_IR_149,  // korean
    ISO_2022_IR_58,  // simplified chinese
    ISO_IR_192,  // utf-8
    GB18030,  // gb18030
    GBK,  // gbk
    LATIN1 = ISO_2022_IR_100,
    LATIN2 = ISO_2022_IR_101,
    LATIN3 = ISO_2022_IR_109,
    LATIN4 = ISO_2022_IR_110,
    CYRILLIC = ISO_2022_IR_144,
    ARABIC = ISO_2022_IR_127,
    GREEK = ISO_2022_IR_126,
    HEBREW = ISO_2022_IR_138,
    LATIN5 = ISO_2022_IR_148,
    KATAKANA = ISO_2022_IR_13,
    JISX0201 = ISO_2022_IR_13,
    THAI = ISO_2022_IR_166,
    JISX0208 = ISO_2022_IR_87,
    KANJI = ISO_2022_IR_87,
    JAPANESE = ISO_2022_IR_87,
    JISX0212 = ISO_2022_IR_159,
    KANJISUPP = ISO_2022_IR_159,
    KOREAN = ISO_2022_IR_149,
    KSX1001 = ISO_2022_IR_149,
    GB2312 = ISO_2022_IR_58,
    UTF8 = ISO_IR_192,
    UNKNOWN = -1
  } type;

  static type from_string(const char *s, size_t size); // CHARSET::from_string
  static type from_string(const std::string &s); // CHARSET::from_string
  static const char* term(type charset);
  static const char* description(type charset);
};
typedef CHARSET::type charset_t;

std::wstring convert_to_unicode(const char* inbuf, size_t inbuflen,
                                charset_t charset);
std::string convert_from_unicode(const wchar_t *inbuf, size_t inbuflen,
                                charset_t charset);

// Buffer ======================================================================

template <typename T>
struct Buffer {
  T* data;
  size_t size;  /// == number of items; size of allocated bytes / sizeof(T)
  bool owndata;

  Buffer() : data(nullptr), size(0), owndata(false) {}
  Buffer(size_t n) : size(n), owndata(false) { alloc(n); }
  Buffer(T* buf, size_t buflen) : data(buf), size(buflen), owndata(false) {}
  ~Buffer() { this->free(); }

  Buffer(const Buffer&) = delete;
  Buffer& operator=(Buffer&) = delete;
  Buffer(Buffer&& other) {
    data = other.data;
    size = other.size;
    owndata = other.owndata;
    other.data = nullptr;
    other.size = 0;
    other.owndata = false;
  }
  Buffer& operator=(Buffer&&) = delete;

  T& operator[](size_t idx) { return data[idx]; }

  void set(T* buf, size_t buflen);
  T* alloc(size_t n);
  T* realloc(size_t n);
  void free();

  operator std::string() const {
    return std::string((const char*)data, size * sizeof(T));
  };
};

template <typename T>
void Buffer<T>::set(T* buf, size_t buflen) {
  data = buf;
  size = buflen;
}

template <typename T>
T* Buffer<T>::alloc(size_t n) {
  free();
  data = (T*)::malloc(n * sizeof(T));
  if (data) {
    size = n;
    owndata = true;
    return data;
  } else {
    // memory error
    return nullptr;
  }
}

template <typename T>
T* Buffer<T>::realloc(size_t n) {
  if (owndata) {
    uint8_t* tmpdata = (uint8_t*)::realloc(data, n * sizeof(T));
    if (tmpdata) {
      data = tmpdata;
      size = n;
      return data;
    } else {
      // data is untouched
      return nullptr;
    }
  } else {
    uint8_t* tmpdata = (uint8_t*)::malloc(n * sizeof(T));
    if (tmpdata) {
      ::memcpy(tmpdata, data, n * sizeof(T));
      data = tmpdata;
      size = n;
      owndata = true;
      return data;
    } else {
      // data is untouched
      return nullptr;
    }
  }
}
template <typename T>
void Buffer<T>::free() {
  if (owndata && data) ::free(data);
  data = nullptr;
  size = 0;
  owndata = false;
}

// DataElement =================================================================

class DataElement {
 public:
  tag_t tag_;
  vr_t vr_;
  size_t length_;
  size_t offset_;  // value offset in the stream.
  union {  // hold binary data or sequence or pixel sequence.
    void* ptr_;
    Sequence *seq_;
    PixelSequence *pixseq_;
  };
  DataSet* parent_;  // parent DataSet.

  DataElement(tag_t tag, vr_t vr, size_t length, size_t offset, DataSet* parent);
  ~DataElement();
  DataElement(const DataElement&) = delete;
  DataElement(const DataElement&&) = delete;

  /// Returns value as unicode string. Leading and trailing spaces are stripped
  /// according to the VR. Elements with binary value cannot convert to the
  /// string. May throw exception if error is occurred during unicode
  /// conversion.
  std::wstring toString(const wchar_t* default_value = L"");
  std::vector<std::wstring> toStringVector();

  /// Returns value as string without conversion. Leading and trailing spaces
  /// are stripped according to the VR.
  std::string toBytes(const char* default_value = "");

  std::wstring repr(size_t max_length);

  long toLong(long default_value = 0);
  long long toLongLong(long long default_value = 0);
  std::vector<long> toLongVector();
  std::vector<long long> toLongLongVector();
  double toDouble(double default_value = 0.0);
  std::vector<double> toDoubleVector();

  inline Sequence* toSequence() { return (vr_ == VR::SQ ? seq_ : nullptr); }
  inline PixelSequence* toPixelSequence() {
    return (vr_ == VR::PIXSEQ ? pixseq_ : nullptr);
  }

  /// Return memory pointer where DataElement's raw value is stored. It can be
  /// on the mmap'ed disk or allocated memory.
  void* value_ptr();

  /// Return Buffer<T> which contains DataElement's value. Byte order swapping
  /// is done according to the machines endianess, transfer syntax, and VR.
  template <typename T>
  Buffer<T> toBuffer();

  // set value functions
  void fromLong(const long value);
  void fromLongLong(const long long value);
  void fromLongVector(const std::vector<long>& value);
  void fromLongLongVector(const std::vector<long long>& value);
  void fromDouble(const double value);
  void fromDoubleVector(const std::vector<double>& value);

  void fromString(const wchar_t* value, size_t length = -1);
  void fromString(const std::wstring& value);
  void fromStringVector(const std::vector<std::wstring>& value);
  void fromBytes(const char* value, size_t length = -1);  // set rawvalue
  void fromBytes(const std::string& value);

  // getter functions
  // ----------------------------------------------------------

  inline size_t length() const {  // wrapper
    return length_;
  }

  inline vr_t vr() const {  // wrapper
    return vr_;
  }

  inline tag_t tag() const {  // wrapper
    return tag_;
  }

  inline size_t offset() const {  // wrapper
    return offset_;
  }

  int vm();

  static DataElement* NullElement() {
    static DataElement null(0x0, VR::NONE, 0, 0, nullptr);
    return &null;
  }

  inline bool isValid() const { return vr_ != VR::NONE; }

  // setter functions
  // ----------------------------------------------------------

  inline void setOffset(size_t offset) { offset_ = offset; }
  inline void setLength(size_t length) { length_ = length; }

 private:
  // Allocate size bytes memory to `ptr_`. `_free_ptr()` set `ptr_` to
  // `nullptr` if size is zero. `length_` is set to size. `size` should be
  // even.
  void alloc_ptr_(size_t size);
  // Free memory if `ptr_` is not null. `ptr_` is set to `nullptr`.
  void _free_ptr();

  template <typename AVT>
  bool _fromNumberVector(const std::vector<AVT>& value);
  template <typename AVT, typename SVT>
  void _fromNumberVectorToBytes(const std::vector<AVT>& value);
  template <typename AVT>
  void _fromNumberVectorToAttrTags(const std::vector<AVT>& value);
  template <typename AVT, typename SVT>
  void _fromNumberVectorToString(const std::vector<AVT>& value);
};

// DataSet =====================================================================

class DataSet {
  DataSet *root_dataset_;

  std::map<tag_t, std::unique_ptr<DataElement>> edict_;
  std::unique_ptr<InStream> is_;

  tag_t last_tag_loaded_;
  uint8_t buf8_[8];  // temporary buffer for tag, vr and length

  tsuid_t transfer_syntax_;

  // first character set for convert_to_unicode argument
  charset_t specific_charset0_;
  // last character set for convert_from_unicode argument
  charset_t specific_charset1_;

  size_t offset_in_stream_;  // location in the file (for DICOMDIR)

 public:
  DataSet();
  DataSet(DataSet* parent);
  ~DataSet();
  DataSet(DataSet& other) = delete;
  DataSet(DataSet&& other) = delete;

  DataElement* addDataElement(tag_t tag, vr_t vr = VR::NONE,
                              uint32_t length = 0, size_t offset = 0);
  DataElement* addDataElement(const char *tagstr, vr_t vr = VR::NONE);
  DataElement* getDataElement(tag_t tag);
  DataElement* getDataElement(const char *tagstr);
  inline DataElement& operator[](tag_t tag) { return *getDataElement(tag); }
  inline DataElement& operator[](const char* tagstr) {
    return *getDataElement(tagstr);
  }

  inline int size() { return (int)edict_.size(); }

  void removeDataElement(tag_t tag);  /// Remove a data element.

  void attachToMemory(const uint8_t* data, size_t datasize, bool copy_data);
  void attachToFile(const char* filename);
  void attachToInstream(InStream *basestream, size_t size);
  void detach();  /// delete InFileStream or InMemoryStream object

  void load(tag_t load_until, InStream *instream);
  void loadDicomFile(tag_t load_until);

  // Config::set("SAVE_SQ_EXPLICIT_LENGTH", "TRUE")
  // Config::set("SAVE_SQ_EXPLICIT_LENGTH", "FALSE")
  // - Write explicit length of Sequence and its DataSet items if "TRUE".
  // Config::set("WRITE_METAINFO", "TRUE")
  // Config::set("WRITE_METAINFO", "FALSE")
  // - Write File Meta Information if "TRUE".
  // Config::set("WRITE_PREAMBLE", "TRUE")
  // Config::set("WRITE_PREAMBLE", "FALSE")
  // - Write preamble 132 bytes (128 '\0's and "DICM") if "TRUE".
  void saveToStream(std::ostream& oss);
  void saveToFile(const char *filename);
  std::string saveToMemory();

  void close();

  inline InStream* instream() { return is_.get(); }

  inline bool isExplicitVr() const {
    return transfer_syntax_ != UID::IMPLICIT_VR_LITTLE_ENDIAN;
  }
  inline bool isLittleEndian() const {
    return transfer_syntax_ != UID::EXPLICIT_VR_BIG_ENDIAN;
  }
  inline tsuid_t getTransferSyntax() const {
    return (this == root_dataset_ ? transfer_syntax_
                                  : root_dataset_->transfer_syntax_);
  }
  charset_t getSpecificCharset(int index = 0);
  void setSpecificCharset(charset_t charset);

  // get/set offset in the file (for DICOMDIR)
  // PS3.3 Table F.3-3. Directory Information Module Attributes
  // PS3.10 A.1 Simple Directory Content Example
  inline size_t getOffset() { return offset_in_stream_; }
  inline void setOffset(size_t offset) { offset_in_stream_ = offset; }

  inline decltype(edict_)::iterator begin() {
    return edict_.begin();
  }
  inline decltype(edict_)::iterator end() {
    return edict_.end();
  }
  
  std::wstring dump(size_t max_length=120);

  void copyFrameData(size_t index, uint8_t *data, int datasize, int rowstep);
};

// if keep_on_error is true, ignore exception and return partially decoded
// DataSet.
std::unique_ptr<DataSet> open_file(const char* filename,
                                   tag_t load_until = 0xffffffff,
                                   bool keep_on_error = false);
std::unique_ptr<DataSet> open_memory(const uint8_t* data, size_t datasize,
                                     bool copy_data = true,
                                     tag_t load_until = 0xffffffff,
                                     bool keep_on_error = false);


// Sequence ====================================================================

class Sequence {
  DataSet* root_dataset_;

  tsuid_t transfer_syntax_;

  std::vector<std::unique_ptr<DataSet>> seq_;

 public:
  Sequence(DataSet* root_dataset);
  ~Sequence();
  Sequence(const Sequence&) = delete;
  Sequence(const Sequence&&) = delete;

  void load(InStream* instream);

  inline int size() { return (int)seq_.size(); }

  DataSet* addDataSet();              // wrapper
  DataSet* getDataSet(size_t index);  // wrapper
  DataSet* operator[](size_t index);

  inline decltype(seq_)::iterator begin() {
    return seq_.begin();
  }
  inline decltype(seq_)::iterator end() {
    return seq_.end();
  }

  // void removeDataSet(int idx, bool delete_dataset = true);  // wrapper
  // void removeAll(bool delete_dataset = true);  // wrapper
};

// PixelSequence ===============================================================


struct PixelSequenceItem {
  // Start position in the DICOM file.
  // Item value's position is `position` + 4 (Item Tag) + 4 (Item length)
  size_t position;

  // Item Length.
  // Next item's position == this.position + 4 + 4 + this.length
  size_t length;
};

struct PixelFrame {
  std::vector<PixelSequenceItem> pixseq_items_;

 public:
  // `frag_offsets_`, `startoffset_`, `endoffset_` are set only when
  // `PixelFrame` is loaded from `InStream`. Encoded pixel data are on the
  // `InStream`.

  // start and endoffset pair of pixel fragments [start] [end] [start] [end] ...
  std::vector<size_t> frag_offsets_;
  // start offset in `InStream`.
  size_t startoffset_;
  // end offset in `InStream` (== `startoffset_` of next frame.)
  size_t endoffset_;

  // `encoded_data_`, `encoded_data_size_` are used only when `PixelFrame` is
  // created by user. Encoded pixel data are on the `encoded_data_`.

  uint8_t* encoded_data_;     // encoded pixel data.
  size_t encoded_data_size_;  // length of encoded pixel data.

  PixelFrame();
  ~PixelFrame();

  // load a frame from instream; should be called from
  // PixelSequence::loadFrames().
  // buf should be uint8_t[8];
  void load(InStream* instream, size_t frame_length, uint8_t* buf);

  // setEncodedData() should be called from PixelSequence::setEncodedFrameData()
  void setEncodedData(uint8_t* data, size_t size);

 public:
  size_t encodedDataSize() { return encoded_data_size_; };
  void addItem(PixelSequenceItem item);
};

class PixelSequence {
  void readItems_(std::vector<PixelSequenceItem>& pixseq_items);
  void assembleItemsWithoutBasicOffsetTable_(
      std::vector<PixelSequenceItem>& pixseq_items);
  void assembleItemsWithBasicOffsetTable_(
      std::vector<PixelSequenceItem>& pixseq_items);

  std::vector<std::unique_ptr<PixelFrame>> frames_;
  std::unique_ptr<InStream> is_;  // InSubStream

  DataSet *root_dataset_;
  tsuid_t transfer_syntax_;
  bool jpeg_transfer_syntex_;

  size_t base_offset_;  // base offset to calculate actual offset from offset_table

 public:
  PixelSequence(DataSet *root_dataset, tsuid_t tsuid);
  ~PixelSequence();
  PixelSequence(const PixelSequence&) = delete;
  PixelSequence(const PixelSequence&&) = delete;

  PixelFrame* addPixelFrame();

  void attachToInstream(InStream* basestream, size_t size);

  void loadFrames();

  inline decltype(frames_)::iterator begin() { return frames_.begin(); }
  inline decltype(frames_)::iterator end() { return frames_.end(); }
  inline InStream* instream() { return is_.get(); }

  inline size_t numberOfFrames() const { return frames_.size(); }

  // return start and end offset of `frame` with `index`
  size_t frameOffset(size_t index, size_t& end_offset);

  // return start and end offset of `fragments` in the `frame`.
  // [start] [end] [start] [end] ...
  // returned vector size is 2 * number of fragments.
  std::vector<size_t> frameFragmentOffsets(size_t index);
  void copyDecodedFrameData(size_t index, uint8_t* data, int datasize,
                            int rowstep);

  void setEncodedFrameData(size_t index, uint8_t* data, size_t datasize);

  Buffer<uint8_t> encodedFrameData(size_t index);
  size_t encodedFrameDataSize(size_t index);
};

// load/unload codec for encoding/decoding pixels
void load_codec(char *codec_filename);
void unload_codec(char *codec_filename);

// Exception ===================================================================

class DicomException : public std::exception {
 public:
  explicit DicomException(const char* m) : message{m} {}
  virtual const char* what() const noexcept override { return message.c_str(); }

 private:
  std::string message = "";
};

DicomException build_exception(const char* m, ...);
#define EXCEPTION(...) build_exception(__VA_ARGS__);
#define LOGERROR_AND_THROW(...)     \
  do {                          \
    LOG_ERROR(__VA_ARGS__);     \
    throw EXCEPTION(__VA_ARGS__) \
  } while (0);

#define THROW_ERROR(...)     \
  do {                          \
    throw EXCEPTION(__VA_ARGS__) \
  } while (0);


// PixelSequence ===============================================================

class Config {
  std::map<std::string, std::string> dict_;

 public:
  static Config& getInstance() {
    static Config instance;
    return instance;
  }

  static const char* get(const char *key, const char *default_value) {
    return Config::getInstance()._get(key, default_value);
  }
  static void set(const char *key, const char *value){
    Config::getInstance()._set(key, value);
  }
  static long getInteger(const char *key, long default_value) {
    return Config::getInstance()._getInteger(key, default_value);
  }
  static void setInteger(const char *key, const long value) {
    Config::getInstance()._setInteger(key, value);
  }

  Config() = default;
  ~Config() = default;

 private:
  const char* _get(const char *key, const char *default_value);
  void _set(const char *key, const char *value);
  long _getInteger(const char *key, long default_value);
  void _setInteger(const char *key, long value);

  Config(const Config&) = delete;
  Config& operator=(const Config&) = delete;
};

// Logger ======================================================================

struct LogLevel {
  typedef enum {
    DEBUG = 10,
    WARN = 20,
    ERROR = 30,
    DISABLE = 100,
  } type;
};

typedef std::function<void(LogLevel::type, const char*)> LoggerFunctionType;

void set_loglevel(LogLevel::type loglevel);
LogLevel::type get_loglevel();
void set_logger_function(LoggerFunctionType& logfunc);
void set_default_logger_function();
void log_message(LogLevel::type loglevel, const char* format, ...);

#ifdef DEBUG_MESSAGE
#define LOG_DEBUG(...)                          \
  do {                                          \
    if (get_loglevel() <= LogLevel::DEBUG)       \
      log_message(LogLevel::DEBUG, __VA_ARGS__); \
  } while (0)
#else
#define LOG_DEBUG(...)
#endif // DEBUG_MESSAGE

#define LOG_WARN(...)                          \
  do {                                         \
    if (get_loglevel() <= LogLevel::WARN)       \
      log_message(LogLevel::WARN, __VA_ARGS__); \
  } while (0)

#define LOG_ERROR(...)                          \
  do {                                          \
    if (get_loglevel() <= LogLevel::ERROR)       \
      log_message(LogLevel::ERROR, __VA_ARGS__); \
  } while (0)

}  // namespace dicom

#endif  // DICOMSDL_DICOM_H_

